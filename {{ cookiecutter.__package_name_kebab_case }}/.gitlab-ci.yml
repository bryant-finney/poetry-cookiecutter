# pattern: jobs are generally named according to '{emoji} {function}:{object}[:{category}]'
# pattern: jobs are generally ordered by execution stage; properties are ordered alphabetically
# ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ‚éØ

stages:
  - build
  - test
  - {% if cookiecutter.with_fastapi_api|int or cookiecutter.with_streamlit_app|int %}deploy{% else %}publish{% endif %}


üèó build:ci-image:docker:
  # use GitLab's docker-in-docker solution to build the image for CI jobs
  after_script: [docker logout]
  before_script:
    - >
      echo "$DOCKER_REGISTRY_PASSWORD" |
        docker login --username "$DOCKER_REGISTRY_USER" --password-stdin "$DOCKER_REGISTRY"

  image: docker:stable

  script:
    # Compile a list of image tags consisting of a hash of its contents, the latest tag if this
    # pipeline is running for the default branch, and the Git tag if this commit is tagged.
    - |
      DOCKER_TAGS="$DOCKER_IMAGE_SHA"
      if [ "$CI_COMMIT_BRANCH" = "$CI_DEFAULT_BRANCH" ]; then DOCKER_TAGS="$DOCKER_TAGS latest"; fi
      if [ -n "$CI_COMMIT_TAG" ]; then DOCKER_TAGS="$DOCKER_TAGS $CI_COMMIT_TAG"; fi
      if [ -n "$CI_ENVIRONMENT_NAME" ]; then DOCKER_TAGS="$DOCKER_TAGS $CI_ENVIRONMENT_NAME"; fi
      DOCKER_TAGS_JOINED=""
      for DOCKER_TAG in $DOCKER_TAGS; do
        DOCKER_TAGS_JOINED="$DOCKER_TAGS_JOINED --tag $DOCKER_IMAGE:$DOCKER_TAG"
      done

    # Build the Docker image with all of the selected tags.
    - |
      {%- if cookiecutter.private_package_repository_name %}
      echo "[http-basic.{{ cookiecutter.private_package_repository_name|slugify }}]" >> auth.toml
      echo "username = \"gitlab-ci-token\"" >> auth.toml
      echo "password = \"$CI_JOB_TOKEN\"" >> auth.toml
      {%- endif %}
      docker build \
        --cache-from "$CI_REGISTRY_IMAGE/ci:$CI_IMAGE_SHA" \
        --build-arg SOURCE_BRANCH="$CI_COMMIT_REF_NAME" \
        --build-arg SOURCE_COMMIT="$CI_COMMIT_SHA" \
        --build-arg SOURCE_TIMESTAMP="$CI_COMMIT_TIMESTAMP" \
        {%- if cookiecutter.private_package_repository_name %}
        --secret id=poetry_auth,src=auth.toml \
        {%- endif %}
        --target "$DOCKER_TARGET" \
        --pull \
        $DOCKER_TAGS_JOINED \
        .

    # Push all the tagged images.
    - |
      for DOCKER_TAG in $DOCKER_TAGS; do
        docker push "$DOCKER_IMAGE:$DOCKER_TAG"
      done

  services: [docker:stable-dind]
  stage: build

  variables:
    DOCKER_BUILDKIT: "1"
    DOCKER_IMAGE: $CI_REGISTRY_IMAGE/ci
    DOCKER_REGISTRY: $CI_REGISTRY
    DOCKER_REGISTRY_PASSWORD: $CI_REGISTRY_PASSWORD
    DOCKER_REGISTRY_USER: $CI_REGISTRY_USER
    DOCKER_TARGET: ci

.test:
  # define common properties to share between test jobs
  before_script:
    {%- if cookiecutter.private_package_repository_name %}
    - poetry config http-basic.{{ cookiecutter.private_package_repository_name|slugify }} "gitlab-ci-token" "$CI_JOB_TOKEN"
    {%- endif %}
    # TODO: Add `--only test` when Poetry 1.2.0 is released.
    - poetry install --no-interaction


  cache:
    key: $CI_COMMIT_REF_SLUG
    paths:
      - .mypy_cache/
      - .pytest_cache/

  image: $CI_REGISTRY_IMAGE/ci:$CI_IMAGE_SHA
  needs:
    - job: üèó build:ci-image:docker
      optional: true
  stage: test


‚òÄÔ∏è lint:package:style:
  artifacts:
    untracked: true
    reports:
      junit: [reports/mypy.xml]
  extends: [.test]
  script: [poe lint]


üß™ test:package:functionality:
  artifacts:
    reports:
      coverage_report:
        coverage_format: cobertura
        path: reports/coverage.xml
      junit: [reports/pytest.xml]
    untracked: true
    when: always

  coverage: '/^TOTAL.*\s+(\d+(?:\.\d+)?)%/'
  extends: [.test]
  script: [poe test]

{% if not cookiecutter.with_fastapi_api|int and not cookiecutter.with_streamlit_app|int -%}
# Publish this package version to a (private) package repository.
üåê publish:package:
  stage: publish
  image: $CI_REGISTRY_IMAGE/ci:$CI_IMAGE_SHA
  script:
    {%- if cookiecutter.private_package_repository_name %}
    - poetry config repositories.private "{{ cookiecutter.private_package_repository_url.replace('simple/', '').replace('simple', '') }}"
    - poetry config http-basic.private "gitlab-ci-token" "$CI_JOB_TOKEN"
    - poetry publish --build --repository private
    {%- else %}
    - poetry config pypi-token.pypi "$POETRY_PYPI_TOKEN_PYPI"
    - poetry publish --build
    {%- endif %}
  only:
    - tags
{%- else -%}
# Build the application as a Docker image and push it to the GitLab registry.
.deploy:
  extends:
    - .docker
  stage: deploy
  variables:
    DOCKER_IMAGE: $CI_REGISTRY_IMAGE
    DOCKER_IMAGE_SHA: ${CI_COMMIT_TAG:-$CI_COMMIT_SHORT_SHA}
    DOCKER_PUSH: 1
    DOCKER_TARGET: app
  when: manual
{% for environment in ["feature", "development", "test", "acceptance", "production"] %}
Deploy ({{ environment }}):
  extends:
    - .deploy
  environment: {{ environment }}
  {%- if environment in ["acceptance", "production"] %}
  only:
    - tags
  {%- endif %}
{% endfor %}
{%- endif %}
